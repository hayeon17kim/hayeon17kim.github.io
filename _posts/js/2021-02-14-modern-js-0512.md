---
title: "모던 자바스크립트 #5.12 JSON과 메서드"
categories: JavaScript
tags: [ JavaScript, modernJS ]
---

[모던 JavaScript 튜토리얼](https://ko.javascript.info/)을 따라가면서 정리합니다.

네트워크를 통해 객체를 보내거나 로깅 목적으로 객체를 출력할 때는 객체를 문자열로 전환한다. 이 전환된 문자열에는 객체 프로퍼티 모두가 포함되어야만 한다. 

한 번 `toString()` 메서드를 구현한다고 해도, 프로퍼티를 추가할 때마다 `toString()` 을 계속 수정해야 하기 때문에 번거롭다. 프로퍼티에 반복문을 돌리는 것은 중첩 객체 등으로 객체가 복잡한 경우 까다롭다. 자바스크립트는 이런 문제를 해결하기 위해 `JSON.stringify`를 제공해준다.

`JSON.stringify` 을 사용하면 원하는 값을 JSON으로 직렬화한다. 변경된 문자열은 인코딩된(JSON-encoded), 직렬화처리된(serialized), 결집된(marshalled) 객체라고 한다. `JSON.parse` 를 사용하면 JSON을 본래의 값으로 역직렬화할 수 있다. 

## JSON.stringify

JSON은 독자적인 표준을 가진 데이터 형식으로, 대부분의 언어에는 JSON을 쉽게 다룰 수 있게 해주는 라이브러리가 있다. 따라서 주로 데이터 교환 목적으로 사용한다. JSON은 일반 객체, 배열, 문자열, 숫자, 불린값, null을 지원한다.

`JSON.stringify` 호출 시 무시되는 프로퍼티는 다음과 같다.

- 함수 프로퍼티
- 심볼형 프로퍼티 (키가 심볼인 프로퍼티)
- 값이 `undefined` 인 프로퍼티

```js
let user = {
  sayHi() { // 무시
    alert("Hello");
  },
  [Symbol("id")]: 123, // 무시
  something: undefined // 무시
};

alert( JSON.stringify(user) ); // {}
```

이때 다음과 같이 순환 참조가 있으면 원하는대로 객체를 문자열로 바꾸는 게 불가능하다.

```js
let room = { number: 23 };
let meetup = { 
  title: "Conference", 
  participants: {
    name: "john",
    name: "ann"
};

meetup.place = room;
room.occupiedBy = meetup;

JSON.stringify(meetup); //Error: Converting circular structure to JSON
```

**replacer 로 원하는 프로퍼티만 직렬화하기**

```js
let json = JSON.stringify(value[, replacer, space]);
```

- value: 인코딩하려는 값
- replacer: JSON으로 인코딩하길 원하는 프로퍼티가 담긴 배열 혹은 매핑 함수 `function(key, value)`
- space: 서식 변경 목록으로 사용할 공백 문자 수

```js
JSON.stringify(meetup, ['title', 'participants']);
// {"title": "Conference", "participants":[{}, {}]}
```

배열에 name을 넣치 않아서 participants가 텅 비어버렸다. 규칙이 너무 까다로워서 발생한 문제이다. 그렇다면 모든 프로퍼티를 담은 배열을 파라미터로 전달해야 할까? 그럼 배열이 너무 길어질 것이다. 이때 `replacer` 자리에 배열 대신 함수를 전달해 문제를 해결할 수 있다. 

```js
JSON.stringify(meetup, function replacer(key, value) {
  return (key == 'occupiedBy') ? undefined;
}) 
```

이 경우 첫 얼럿창에 `": [object Object]"`가 뜨는데, 이는 **함수가 최초로 호출될 때 `{"": meetup}` 형태의 "래퍼 객체"가 만들어지기 때문이다.** 즉 replacer 함수가 가장 처음으로 처리해야 하는 `(key, value)` 상에서 키는 빈 문자열, 값은 변환하고자 하는 객체(meetup) 전체가 된다.

**space로 가독성 높이기**

세 번째 인수인 `space` 는 가독성을 높이기 위해 중간에 삽입해 줄 공백 문자 수를 나타낸다. 따라서 단순 전달 목적이라면 `space` 없이 직렬화하는 편이다. 

```js
alert(JSON.stringify(user, null, 2));
```

`JSON.stringify` 는 객체의 `toJSON` 을 자동으로 호출해준다. `toString()` 처럼 `toJSON`을 커스텀해서 사용할 수 있다!

### JSON.parse

```js
let value = JSON.parse(str, [reviver]);
```

- `reviver`: 모든 `(key, value)` 쌍을 대상으로 호출되는 `function(key, value)` 형태의 함수로 값을 변경시킬 수 있다.
- JSON 포맷을 지키는 것이 중요하다. 다음은 JSON을 직접 만들 때 흔히 하는 실수이다. 

```js
let json = `{
  name: "John",                     // 실수 1: 프로퍼티 이름을 큰따옴표로 감싸지 않았습니다.
  "surname": 'Smith',               // 실수 2: 프로퍼티 값은 큰따옴표로 감싸야 하는데, 작은따옴표로 감쌌습니다.
  'isAdmin': false                  // 실수 3: 프로퍼티 키는 큰따옴표로 감싸야 하는데, 작은따옴표로 감쌌습니다.
  "birthday": new Date(2000, 2, 3), // 실수 4: "new"를 사용할 수 없습니다. 순수한 값(bare value)만 사용할 수 있습니다.
  "friends": [0,1,2,3]              // 이 프로퍼티는 괜찮습니다.
}`;
```

- 또한 JSON은 주석을 지원하지 않는다. 
- JSON 포맷이 까다로운 것은 쉽고 빠르며 신뢰할 수 있는 파싱 알고리즘을 구현하기 위해서다.

**`reviver` 사용하기**

```js
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert( meetup.date.getDate() ); // 에러! 
```

`meetup.date`의 값이 `Date` 객체가 아니라 문자열이기 때문에 에러가 발생했다. 문자열을 `Date` 으로 전환해줘야 한다는 것을 `reviver`를 통해  `JSON.parse`에게 알려줘야 한다.

```js
let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});
```

## 과제

**1. 객체를 JSON으로 바꾼 후 다시 객체로 바꾸기**

```js
let user = {
  name: "John Smith",
  age: 35
};

let json = JSON.stringify(user);
let userAgain = JSON.parse(json);
```

**2. 역참조 배제하기**

```js
let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupied: [{name: "John"}, {name: "Alice"}],
  place: room
};

room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  return key == 'occupiedBy' || key == 'self' ? undefined : value;
}));
```



