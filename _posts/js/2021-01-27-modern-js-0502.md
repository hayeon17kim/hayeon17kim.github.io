---
title: "모던 자바스크립트 #5.2. 숫자형"
categories: JavaScript
tags: [ JavaScript, modernJS ]
---

[모던 JavaScript 튜토리얼](https://ko.javascript.info/)을 따라가면서 정리합니다.

## 5.2. 숫자형

- 0이 많이 붙은 숫자는 다음과 같이 표현할 수 있다.

  - 0의 개수를 `'e'` 뒤에 추가한다. `123e6`은 0이 6개인 숫자, 123000000을 나타낸다.
  - `'e'` 다음에 음수가 오면, 음수의 절대값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눈다. `123e-6`은 `0.000123`을 나타낸다. 

- 진법을 이용할 수 있다.

  - 자바스크립트는 특별한 변환 없이 16진수(`0x`), 8진수(`0o`), 2진수(`0b`)를 바로 사용할 수 있게 지원한다.
  - `parseInt(str, base)`를 사용하면 `str`을 `base` 진수로 바꿔준다. (단, `2 <= base < 26`)
  - `num.toString(base)`는 숫자를 `base` 진수로 바꾸고, 이를 문자열 형태로 반환한다.

- `12pt`나 `100px`과 같은 값을 숫자로 변환할 수 있다.

  - `parseInt/parseFloat`을 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 '약한' 형변환을 사용할 수 있다.

- 부정확한 계산

  숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그런데 10진법을 사용하면 쉽게 표현할 수 있는 0.1, 0.2 같은 분수는 이진법으로 표현하면 무한 소수가 된다.

  0.1은 1을 10으로 나눈 수인 1/10이다. 10의 거듭제곱으로 나눈 값은 10진법에서는 잘 작동하지만, **3으로 나누게 되면 10진법에서 제대로 동작하지 않는다**. 같은 이유로 **2진법 체계에서는 2의 거듭제곱으로 나눈 값은 잘 동작하지만, 1/10과 같이 2의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버린다.**

  10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없다. IEEE-754에서는 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이 문제를 해결한다. 

- 소수를 처리하는 데 쓰이는 메서드

  `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round`, `num.toFixed(precision)`

- `isNaN`와 `isFinit`

  -  `Infinity`와 `-Infinity`, `NaN`은 숫자형에 속하지만 정상적인 숫자는 아니기 때문에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

  - `isNaN(value)`: 인수를 숫자로 변환한 다음 `NaN`인지 테스트함

    `NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 결과값과도 갖지 않다. 따라서 동등비교연산이 아니라 이 메서드가 필요한 것이다.

    ```js
    alert(isNaN(NaN)); //true
    alert(isNaN("str")); // true
    alert( NaN === NaN ); // false
    ```

  - `isFinite(value)`: 인수를 숫자로 변환하고, 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환함.

- `Object.is`와 비교하기

  두 가지 에지 케이스에서는 `===`보다 신뢰할 만한 결과를 보여준다.

  - `NaN`을 대상으로 비교할 때: `Object.is(NaN, NaN) === true`
  - `0`과 `-0`이 다르게 취급될 때: `Object.is(0, -0) === false`